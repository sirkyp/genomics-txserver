<div style="display: flex; gap: 20px; margin-bottom: 20px;">
  <div style="flex: 1;">
    <h6>Memory Usage (Heap Used)</h6>
    <canvas id="memoryChart" height="200"></canvas>
  </div>
  <div style="flex: 1;">
    <h6>Requests per Minute</h6>
    <canvas id="requestChart" height="200"></canvas>
  </div>
</div>
<div style="display: flex; gap: 20px; margin-bottom: 20px;">
  <div style="flex: 1;">
    <h6>CPU Usage (%)</h6>
    <canvas id="cpuChart" height="200"></canvas>
  </div>
  <div style="flex: 1;">
    <h6>Node Blocking</h6>
    <canvas id="blockChart" height="200"></canvas>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(function() {
  const historyData = {{ historyJson }};
  const startTime = {{ startTime }};

  function formatTime(timestamp) {
    const d = new Date(timestamp);
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function formatMB(bytes) {
    return (bytes / 1024 / 1024).toFixed(1);
  }

  function formatDuration(ms) {
    const hours = ms / 3600000;
    if (hours < 1) {
      return Math.round(ms / 60000) + 'm ago';
    }
    return hours.toFixed(1) + 'h ago';
  }

  const chartOptions = {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        ticks: {
          maxTicksAuto: 6
        }
      },
      y: {
        beginAtZero: true
      }
    },
    plugins: {
      legend: {
        display: false
      }
    }
  };

  // Memory chart
  new Chart(document.getElementById('memoryChart'), {
    type: 'line',
    data: {
      labels: historyData.map(d => formatTime(d.time)),
      datasets: [{
        data: historyData.map(d => parseFloat(formatMB(d.mem))),
        borderColor: '#007bff',
        backgroundColor: 'rgba(0, 123, 255, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 2
      }]
    },
    options: {
      ...chartOptions,
      scales: {
        ...chartOptions.scales,
        y: {
          ...chartOptions.scales.y,
          title: {
            display: true,
            text: 'MB (ðš« from start)'
          }
        }
      }
    }
  });

  // CPU chart
  new Chart(document.getElementById('cpuChart'), {
    type: 'line',
    data: {
      labels: historyData.map(d => formatTime(d.time)),
      datasets: [{
        data: historyData.map(d => parseFloat(formatMB(d.cpu))),
        borderColor: '#ff7b00',
        backgroundColor: 'rgba(255, 123, 0, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 2
      }]
    },
    options: {
      ...chartOptions,
      scales: {
        ...chartOptions.scales,
        y: {
          ...chartOptions.scales.y,
          title: {
            display: true,
            text: '%'
          }
        }
      }
    }
  });

  // Requests chart
  new Chart(document.getElementById('requestChart'), {
    type: 'line',
    data: {
      labels: historyData.map(d => formatTime(d.time)),
      datasets: [{
        data: historyData.map(d => d.rpm.toFixed(2)),
        borderColor: '#28a745',
        backgroundColor: 'rgba(40, 167, 69, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 2
      }]
    },
    options: {
      ...chartOptions,
      scales: {
        ...chartOptions.scales,
        y: {
          ...chartOptions.scales.y,
          title: {
            display: true,
            text: 'req/min'
          }
        }
      }
    }
  });
  // Blocking chart
  new Chart(document.getElementById('blockChart'), {
    type: 'line',
    data: {
      labels: historyData.map(d => formatTime(d.time)),
      datasets: [{
        data: historyData.map(d => d.block),
        borderColor: '#2845a7',
        backgroundColor: 'rgba(40, 69, 167, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 2
      }]
    },
    options: {
      ...chartOptions,
      scales: {
        ...chartOptions.scales,
        y: {
          ...chartOptions.scales.y,
          title: {
            display: true,
            text: 'points'
          }
        }
      }
    }
  });
})();
</script>